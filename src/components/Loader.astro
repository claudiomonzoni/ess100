---
interface Props {
  loadingText?: string;
}

const { loadingText = "Loading..." } = Astro.props;
---

<div class="loader-wrapper">
  <div class="loader-container">
    <div class="loader">
      <div class="loader-progress">
        <div class="loader-progress-bar"></div>
      </div>
      <div class="loader-percentage" aria-live="polite">0</div>
    </div>
    {loadingText && <p class="loader-text">{loadingText}</p>}
  </div>
</div>

<style lang="scss">
  @use "../styles/variables.scss" as *;

  .loader-wrapper {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    display: grid;
    place-items: center;
    background-color: white;
    z-index: 9999;
    backdrop-filter: blur(5px);
    transition:
      opacity 0.5s ease-out,
      visibility 0.5s ease-out;
  }

  .loader-container {
    text-align: center;
  }

  .loader {
    position: relative;
    width: 100%;
    margin-bottom: 1rem;
  }

  .loader-progress {
    width: 100%;
    height: 10px;
    background-color: $fondo;
    border-radius: 20rem;
    overflow: hidden;
    margin-bottom: 1rem;
  }

  .loader-progress-bar {
    height: 10px;
    width: 0;
    background: $rojo;
    border-radius: 20rem;
    transition: width 0.3s ease-out;
  }

  .loader-percentage {
    text-align: center;
    font-size: clamp(6rem, 5vw, 7vw);
    font-weight: 600;
    color: $dorado;
    margin-bottom: 0.5rem;
  }

  .loader-text {
    color: $rojo;
    font-size: 1.1rem;
    margin: 0;
    animation: fadeIn 0.5s ease-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<script>
  import { gsap } from "gsap";
  import { SplitText } from "gsap/SplitText";
  
  gsap.registerPlugin(SplitText);

  // Constantes de configuración
  const CONFIG = {
    DURATION: 3000, // Duración total de la animación en ms
    UPDATE_INTERVAL: 30, // Intervalo de actualización en ms
    COMPLETE_DELAY: 1500, // Delay antes de la animación de salida en ms
    HIDE_DELAY: 2000, // Delay antes de ocultar el loader en ms
    FADE_OUT_DURATION: 500, // Duración de la transición de salida en ms
    EXIT_ANIMATION_DURATION: 2, // Duración de la animación de salida del 100 en segundos
    EXIT_STAGGER_AMOUNT: 0.5, // Cantidad de stagger para la animación de salida
  } as const;

  // Selectores
  const SELECTORS = {
    PROGRESS_BAR: ".loader-progress-bar",
    PERCENTAGE: ".loader-percentage",
    WRAPPER: ".loader-wrapper",
  } as const;

  /**
   * Obtiene los elementos del DOM necesarios para el loader
   */
  function getLoaderElements() {
    const progressBar = document.querySelector(
      SELECTORS.PROGRESS_BAR
    ) as HTMLElement | null;
    const percentageElement = document.querySelector(
      SELECTORS.PERCENTAGE
    ) as HTMLElement | null;
    const loaderWrapper = document.querySelector(
      SELECTORS.WRAPPER
    ) as HTMLElement | null;

    return { progressBar, percentageElement, loaderWrapper };
  }

  /**
   * Verifica si todos los elementos necesarios existen
   */
  function areElementsValid(
    progressBar: HTMLElement | null,
    percentageElement: HTMLElement | null,
    loaderWrapper: HTMLElement | null
  ): boolean {
    return !!(progressBar && percentageElement && loaderWrapper);
  }

  /**
   * Actualiza el progreso visual (barra y porcentaje)
   */
  function updateProgressVisuals(
    progressBar: HTMLElement,
    percentageElement: HTMLElement,
    progress: number
  ): void {
    const roundedProgress = Math.min(Math.round(progress), 100);
    percentageElement.textContent = `${roundedProgress}`;
    progressBar.style.width = `${roundedProgress}%`;
  }

  /**
   * Crea y dispara el evento personalizado de carga completa
   */
  function dispatchLoaderCompleteEvent(
    percentageElement: HTMLElement
  ): void {
    const fontSize = window.getComputedStyle(percentageElement).fontSize;
    const event = new CustomEvent("loaderComplete", {
      detail: { fontSize },
    });
    window.dispatchEvent(event);
  }

  /**
   * Oculta y remueve el loader del DOM
   */
  function hideLoader(loaderWrapper: HTMLElement): void {
    loaderWrapper.style.opacity = "0";
    loaderWrapper.style.visibility = "hidden";

    setTimeout(() => {
      loaderWrapper.remove();
    }, CONFIG.FADE_OUT_DURATION);
  }

  /**
   * Anima la salida del número 100 usando GSAP SplitText
   */
  function animateExit100(percentageElement: HTMLElement): void {
    const splitText = new SplitText(percentageElement, {
      type: "chars",
      position: "relative",
    });

    // Configurar estado inicial de cada carácter
    splitText.chars.forEach((char) => {
      gsap.set(char, {
        opacity: 1,
        x: 0,
        y: 0,
        transformOrigin: "center center",
      });
    });

    // Animar salida de los caracteres
    gsap.to(splitText.chars, {
      opacity: 0,
      yPercent: 50,
      duration: CONFIG.EXIT_ANIMATION_DURATION,
      ease: "elastic.out(1, 0.75)",
      stagger: {
        amount: CONFIG.EXIT_STAGGER_AMOUNT,
      },
    });
  }

  /**
   * Maneja la finalización de la carga
   */
  function handleLoadingComplete(
    progressBar: HTMLElement,
    percentageElement: HTMLElement,
    loaderWrapper: HTMLElement
  ): void {
    // Asegurar que la barra muestre 100%
    progressBar.style.width = "100%";
    // Mantener 99 para que se pueda ver el 100% después de completar la animación
    percentageElement.textContent = "99";

    // Iniciar animación de salida del 100
    setTimeout(() => {
      animateExit100(percentageElement);
    }, CONFIG.COMPLETE_DELAY);

    // Ocultar loader y disparar evento después del delay
    setTimeout(() => {
      dispatchLoaderCompleteEvent(percentageElement);
      hideLoader(loaderWrapper);
    }, CONFIG.HIDE_DELAY);
  }

  /**
   * Inicia la animación de progreso
   */
  function startProgressAnimation(
    progressBar: HTMLElement,
    percentageElement: HTMLElement,
    loaderWrapper: HTMLElement
  ): void {
    let progress = 0;
    const increment = (CONFIG.UPDATE_INTERVAL / CONFIG.DURATION) * 100;

    const updateProgress = (): void => {
      if (progress < 100) {
        progress += increment;
        updateProgressVisuals(progressBar, percentageElement, progress);
        requestAnimationFrame(updateProgress);
      } else {
        handleLoadingComplete(progressBar, percentageElement, loaderWrapper);
      }
    };

    requestAnimationFrame(updateProgress);
  }

  /**
   * Inicializa el loader
   */
  function initLoader(): void {
    // Si la página ya está cargada, remover el loader inmediatamente
    if (document.readyState === "complete") {
      const { loaderWrapper } = getLoaderElements();
      loaderWrapper?.remove();
      return;
    }

    // Obtener elementos del DOM
    const { progressBar, percentageElement, loaderWrapper } =
      getLoaderElements();

    // Verificar que todos los elementos existen
    if (
      !areElementsValid(progressBar, percentageElement, loaderWrapper)
    ) {
      return;
    }

    // Iniciar animación de progreso
    startProgressAnimation(
      progressBar!,
      percentageElement!,
      loaderWrapper!
    );
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initLoader);
  } else {
    initLoader();
  }
</script>
